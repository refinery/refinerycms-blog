# Encoding: utf-8

require 'refinery/core/base_model'


module Refinery
  module Blog
    class Category < Core::BaseModel
      extend FriendlyId

      translates :title, :slug

      friendly_id :title, :use => [:slugged, :globalize]
      acts_as_nested_set :dependent => :destroy

      has_many :categorizations, :dependent => :destroy, :foreign_key => :blog_category_id
      has_many :posts, :through => :categorizations, :source => :blog_post

      validates :title, :presence => true, :uniqueness => true

      def self.translated
        with_translations(::Globalize.locale)
      end

      def post_count
        posts.live.with_globalize.count
      end

      # how many items to show per page
      self.per_page = Refinery::Blog.posts_per_page

      
      def nested_url
        globalized_slug = Globalize.with_locale(slug_locale) { to_param.to_s }
        if ::Refinery::Blog.scope_slug_by_parent
          [parent.try(:nested_url), globalized_slug].compact.flatten
        else
          [globalized_slug]
        end
      end

      # Returns an array with all ancestors to_param, allow with its own
      # Ex: with a China category and a Hong Kong underneath,
      # ::Refinery::Blog::Category.find('hongkong').nested_url would return:
      #
      #   ['china', 'hongkong']
      #
      alias_method :uncached_nested_url, :nested_url

      # Returns the string version of nested_url, i.e., the path that should be
      # generated by the router
      def nested_path
        ['', nested_url].join('/')
      end
      
      
      def slug_locale
        return Globalize.locale if translation_for(Globalize.locale).try(:slug).present?

        if translations.empty? || translation_for(Refinery::I18n.default_frontend_locale).present?
          Refinery::I18n.default_frontend_locale
        else
          translations.first.locale
        end
      end
    end
  end
end
